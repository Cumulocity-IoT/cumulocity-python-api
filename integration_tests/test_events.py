# Copyright (c) 2025 Cumulocity GmbH

# pylint: disable=redefined-outer-name, protected-access

from __future__ import annotations

import datetime as dt
import logging
import os
import random
import tempfile
from typing import List

import pytest

from c8y_api import CumulocityApi
from c8y_api.model import Event, Device
from c8y_api.model._util import _DateUtil
from integration_tests.conftest import live_c8y
from util.testing_util import RandomNameGenerator


@pytest.fixture(scope='module')
def sample_events(live_c8y, session_device, module_factory) -> List[Event]:
    """Provide a set of sample Event instances."""
    typename = RandomNameGenerator.random_name()
    now = _DateUtil.now()

    return [
        module_factory(
            Event(type=f'{typename}_{i}', text=f'{typename} text', source=session_device.id,
            time=now + dt.timedelta(minutes=i))
        )
        for i in range(1, 6)
    ]


def test_CRUD(live_c8y: CumulocityApi, session_device: Device):  # noqa (case)
    """Verify that basic CRUD functionality works."""

    typename = RandomNameGenerator.random_name()
    event = Event(c8y=live_c8y, type=typename, text=f'{typename} text', time='now', source=session_device.id)

    created_event = event.create()
    try:
        # 1) assert correct creation
        assert created_event.id
        assert created_event.type == typename
        assert typename in created_event.text
        assert created_event.time  # auto generated by API
        assert created_event.creation_time  # auto generated by Cumulocity

        # 2) update updatable fields
        created_event.text = f'{typename} updated'
        updated_event = created_event.update()
        # -> text should be updated in db
        assert updated_event.text == created_event.text

        # 3) use apply_to
        model_event = Event(c8y=live_c8y, text='some text')
        model_event.apply_to(created_event.id)
        # -> text should be updated in db
        updated_event = live_c8y.events.get(created_event.id)
        assert updated_event.text == 'some text'

    finally:
        created_event.delete()

    # 4) assert deletion
    with pytest.raises(KeyError) as e:
        live_c8y.events.get(created_event.id)
        assert created_event.id in str(e)


def test_CRUD_2(live_c8y: CumulocityApi, session_device: Device):  # noqa (case)
    """Verify that basic CRUD functionality via the API works."""

    typename = RandomNameGenerator.random_name()
    event1 = Event(c8y=live_c8y, type=typename, text=f'{typename} text', source=session_device.id)
    event2 = Event(c8y=live_c8y, type=typename, text=f'{typename} text', source=session_device.id)

    # 1) create multiple events and read from Cumulocity
    live_c8y.events.create(event1, event2)
    events = live_c8y.events.get_all(type=typename)
    event_ids = [e.id for e in events]
    assert len(events) == 2

    try:
        # 2) assert correct creation
        for event in events:
            assert event.id
            assert event.type == typename
            assert typename in event.text
            assert event.time  # auto generated by API
            assert event.creation_time  # auto generated by Cumulocity

        # 3) update updatable fields
        for event in events:
            event.text = 'new text'
        live_c8y.events.update(*events)
        events = live_c8y.events.get_all(type=typename)
        assert len(events) == 2

        # 4) assert updates
        for event in events:
            assert event.text == 'new text'

        # 5) apply updates
        model = Event(text='another update', simple_attribute='value')
        live_c8y.events.apply_to(model, *event_ids)

        # -> the new text should be in all events
        events = live_c8y.events.get_all(type=typename)
        assert len(events) == 2
        assert all(e.text == 'another update' for e in events)

        # 6) use apply_to with json
        live_c8y.events.apply_to({'text': 'updated text', 'add_info': 'yes'}, *event_ids)

        # -> the new text should be in all events
        events = live_c8y.events.get_all(type=typename)
        assert len(events) == 2
        assert all(e.text == 'updated text' for e in events)
        assert all(e.add_info == 'yes' for e in events)

    finally:
        live_c8y.events.delete(*event_ids)

    # 6) assert deletion
    assert not live_c8y.events.get_all(type=typename)


def test_filter_by_update_time(live_c8y: CumulocityApi, session_device, sample_events: List[Event]):
    """Verify that filtering by lastUpdatedTime works as expected."""

    event = sample_events[0]

    # created events should all have different update times
    # -> we use the middle/pivot element for queries
    updated_datetimes = [a.updated_datetime for a in sample_events]
    updated_datetimes.sort()
    pivot = updated_datetimes[len(updated_datetimes)//2]

    before_events = live_c8y.events.get_all(source=event.source, updated_before=pivot)
    after_events = live_c8y.events.get_all(source=event.source, updated_after=pivot, reverse=True)
    last_event_before = live_c8y.events.get_last(source=event.source, updated_before=pivot)
    last_event_after = live_c8y.events.get_last(source=event.source, updated_after=pivot)

    # -> selected events should match the update times from 'before'
    # upper boundary, i.e. before/to timestamp is exclusive -> does not include pivot
    before_datetimes = list(filter(lambda x: x < pivot, updated_datetimes))
    result_datetimes = [a.updated_datetime for a in before_events]
    assert sorted(result_datetimes) == sorted(before_datetimes)
    assert last_event_before.updated_datetime == max(before_datetimes)

    # -> selected events should match the update times from 'after'
    # lower boundary, i.e. after/from timestamp is inclusive -> includes pivot
    after_datetimes = list(filter(lambda x: x >= pivot, updated_datetimes))
    result_datetimes = [a.updated_datetime for a in after_events]
    assert sorted(result_datetimes) == sorted(after_datetimes)
    assert last_event_after.updated_datetime == max(after_datetimes)


def test_select(live_c8y, sample_events):
    """Verify that selecting events works as expected."""

    # 1) use client-side filtering
    event_1 = random.choice(sample_events)
    event_2 = live_c8y.events.get_all(source=event_1.source, filter=f"type == '{event_1.type}'")[0]
    assert event_1.id == event_2.id

    # 2) use type/source
    assert live_c8y.events.get_all(type=event_1.type, source=event_1.source)[0].text == event_1.text


def test_CRUD_attachments(live_c8y: CumulocityApi, session_device: Device, sample_events: List[Event]):  # noqa (case)
    """Verify that creating, reading, updating and deleting of an
    event attachment works as expected."""

    logging.basicConfig(level=logging.INFO)

    event = sample_events[0]
    random_text_1 = bytes(RandomNameGenerator.random_name(num=50, sep=','), 'utf-8')
    random_text_2 = bytes(RandomNameGenerator.random_name(num=50, sep=','), 'utf-8')

    # add a binary attachment via filename
    with tempfile.NamedTemporaryFile(delete=False) as file:
        file.write(random_text_1)
        file.close()
        event.create_attachment(file=file.name, content_type='text/plain')
        os.unlink(file.name)

    # update event object
    event = live_c8y.events.get(event.id)

    # verify that attachment is recognized
    assert event.has_attachment()

    # download and check the binary attachment
    attachment_bytes = event.download_attachment()
    assert attachment_bytes == random_text_1

    # update the attachment
    with tempfile.NamedTemporaryFile() as file:
        file.write(random_text_2)
        file.seek(0)  # reset fp position
        event.update_attachment(file=file)

    # download and check the updated attachment
    attachment_bytes = event.download_attachment()
    assert attachment_bytes == random_text_2

    # remove the attachment
    event.delete_attachment()
    event = live_c8y.events.get(event.id)
    assert not event.has_attachment()


def test_CRUD_attachments_2(live_c8y: CumulocityApi, session_device: Device, sample_events: List[Event]):  # noqa (case)
    """Verify that creating, reading, updating and deleting of an
    event attachment works as expected."""

    event = sample_events[0]
    random_text_1 = bytes(RandomNameGenerator.random_name(num=50, sep=','), 'utf-8')
    random_text_2 = bytes(RandomNameGenerator.random_name(num=50, sep=','), 'utf-8')

    # add a binary attachment via filename
    with tempfile.NamedTemporaryFile(delete=False) as file:
        file.write(random_text_1)
        file.close()
        live_c8y.events.create_attachment(event.id, file=file.name, content_type='text/plain')
        os.unlink(file.name)

    # update event object
    event = live_c8y.events.get(event.id)

    # download and check the binary attachment
    attachment_bytes = live_c8y.events.download_attachment(event.id)
    assert attachment_bytes == random_text_1

    # update the attachment
    with tempfile.NamedTemporaryFile() as file:
        file.write(random_text_2)
        file.seek(0)  # reset fp position
        live_c8y.events.update_attachment(event.id, file=file)

    # download and check the updated attachment
    attachment_bytes = live_c8y.events.download_attachment(event.id)
    assert attachment_bytes == random_text_2

    # remove the attachment
    live_c8y.events.delete_attachment(event.id)
    event = live_c8y.events.get(event.id)
    assert not event.has_attachment()
